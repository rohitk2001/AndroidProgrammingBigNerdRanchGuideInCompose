https://www.notion.so/Chapter-4-Persisting-UI-State-3051feed638a8068a30dc3bbc74aa6ae

ViewModel

It is a class that survives rotation, which we can use to store state.
It is usually scoped to a single screen and is useful place to put logic involved in formatting data to display on screen.

SavedStateHandle: This class allows to temporarily store simple data outside the lifecycle of app’s process(it survives configuration changes).

** can also use rememberSaveable for local properties in compose file, to survive configuration changes.

Including ViewModel Dependency

ViewModel class comes from Android Jetpack library called androidx.lifecycle
Also add androidx.activity.library to add functionality to MainActivity.kt

`implementation("androidx.lifecycle:lifecycle-viewmodel-ktx:2.10.0")`

`implementation("androidx.activity:activity-ktx:1.12.3")`

Adding a ViewModel

Eg: QuizViewModel.kt

`private const val TAG = "QuizViewModel"
class QuizViewModel: ViewModel() {    
     init {        
         Log.d(TAG, "ViewModel instance created")    
     }    
     override fun onCleared() {        
         super.onCleared()        
         Log.d(TAG, "ViewModel instance about to be destroyed")    
     }
}`

Using the ViewModel in Activity

`class MainActivity : ComponentActivity() {    
    private val quizViewModel: QuizViewModel by viewModels()`

       `override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)   
        Log.d(TAG, "Got a QuizViewModel: $quizViewModel")
    }`
`}`

The ‘by’ keyword indicates that a property is implemented using a property delegate.
Property delegate: Its a way in Kotlin to delegate  the functionality of a property to an external unit of code.
Eg: lazy; this allows to save resources by waiting to initialise the property only when it is accessed.
Eg: viewModels(); this works in same way, the view model will not be initialized unless we access it.
When the activity queries for QuizViewModel for first time, viewModels() creates and returns a new QuizViewModel instance.
** When the activity queries for QuizViewModel after configuration change, the instance that was first created is returned.
When activity is finished, the ViewModel - Activity pair is removed from memory.

** If you directly instantiate the view model directly instead of using viewModels() property delegate, it will work the same, BUT will lose the benefit of same instance being returned after your Activity’s configuration change.

ViewModel lifecycle

It survives configuration changes and is destroyed only when its associated activity is finished.
When we associate a ViewModel instance with an activity’s lifecycle, then ViewModel is said to be scoped to that activity’s lifecycle.
This means the ViewModel will remain in memory, regardless of Activity’s state, until Activity is finished, once finished, ViewModel instance is destroyed.

The relationship between MainActivity and QuizViewModel is UNIDIRECTIONAL, activity references the ViewModel but the ViewModel does not access the activity.

**YOUR VIEWMODEL SHOULD NEVER HOLD REFERENCE TO AN ACTIVITY OR VIEW, OTHERWISE YOU WILL INTRODUCE A MEMORY LEAK.

Memory Leak: This occurs when one object holds a strong reference to another object that should be destroyed. The strong reference prevents the garbage collector from clearing the object from memory.

Eg: Your ViewModel instance stays in memory across rotation, while your original activity instance gets destroyed. But if the ViewModel held a strong reference to the original activity instance,  two problems will occur:
1. Original activity instance would not be removed from memory, and thus activity would be leaked.
2. ViewModel would hold reference to stale activity.
** If ViewModel tried to update view of stale activity, it would trigger an IllegalStateException.
So viewmodel will have old activity reference, but new activity willl still have view model reference.

Saving Data Across Process Death

Each app gets its own process(Linux process) containing a single thread to execute UI-related work on and a piece of memory to store objects.
An app’s process can be destroyed by OS, if the user navigates away for a while, and Android needs to reclaim memory.
When an app’s process is destroyed , all the objects stored in that process’s memory are destroyed.
Processes containing resumed or started activities get higher priority than any other processes.
When the OS needs to free up resources it will select lower-priority resources first.
** Practically process containing a visible activity will not be reclaimed by the OS.
So processes that do not have any activities in started or resumed can be killed.
Activities themselves are not individually destroyed in low-memory situations, instead Android clears an entire app process from memory, taking any of the app’s activities with it.

**When OS destroys the app’s process, any of the app’s activities and ViewModel’s stored in memory will be wiped away. There is no guarantee that it will call any of the activity or ViewModel lifecycle callback functions.

SavedStateHandle

Used to store data in saved instance state, which is data the OS temporarily stores outside of the activity.
Eg: 
`const val CURRENT_INDEX_KEY = "CURRENT_INDEX_KEY"
 class QuizViewModel(private val savedStateHandle: SavedStateHandle) : ViewModel() {`

    `private var currentIndex: Int    
      get() = savedStateHandle[CURRENT_INDEX_KEY] ?: 0    
      set(value) = savedStateHandle.set(CURRENT_INDEX_KEY, value) 
}`
The data within SavedStateHandle is “serialised” and written to disk, so we should avoid storing any large or complex objects.
This helps in handling PROCESS DEATH gracefully, by storing imp. changes.
** Before this was introduced, developers used Activity.onSaveInstanceState(Bundle) function to store and to retrieve used Activity.onCreate(Bundle?) function.

State

Since we are now using ViewModel to update values, the composable will be able to read its updates only if state changes.
Eg: QuizViewModel.kt
`private var currentIndexStateFlow: StateFlow<Int> = savedStateHandle.getStateFlow(CURRENT_INDEX_KEY, 0)`

`private var currentIndex: Int    
    get() = currentIndexStateFlow.value    
    set(value) {        
        savedStateHandle[CURRENT_INDEX_KEY] = value    
    }`
MainScreen Composable method
`val currentIndex by quizViewModel.getCurrentIndexFlow().collectAsState()`

** So now, simply collecting the StateFlow is enough to make Compose observe for changes, even if you don't use the resulting currentIndex variable directly in your code.
