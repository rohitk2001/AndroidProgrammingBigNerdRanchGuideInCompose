https://www.notion.so/Chapter-9-Fragments-3091feed638a803e86dde0b228caddb6

UI Flexibility 

Ability to compose and recompose an activity’s view at runtime depending on what the user or device requires.
Activity were not designed with this flexibility in mind, they control an entire window of your application, one Activity should be able to render everything your app needs to show onscreen at a time.
** Activity are tightly coupled to particular screen being used.

Introducing Fragments

This helps in making the UI flexible.
A Fragment has a view of its own, often defined in separate layout file.
Activity acts as a container for the fragments.

Fragments are designed to hold reusable chunks of UI.
Eg: Activity’s view  would compose of list fragment and detail fragment
Therefore selecting another list item would display another/new detail view.

Using fragments separates the UI of your app into building blocks, which is useful for more than just list-detail applications. Working with individual blocks, it is easy to build tab interfaces, tack on animated sidebars, and more.

** A fragment is incapable of getting a view onscreen itself, only when it is inserted in an Activity’s hierarchy will its view appear.

Setting Up a Fragment

In build.gradle file:
`implementation(libs.androidx.fragment.ktx)`
In libs.version.toml file:
`fragmentKtx = "1.5.5"`
`androidx-fragment-ktx = { module = "androidx.fragment:fragment-ktx", version.ref = "fragmentKtx" }`

Creating the Fragment class

Create a Kotlin file for CrimeDetailFragment class.
Eg: `import androidx.fragment.app.Fragment
 class CrimeDetailFragment: Fragment() {    
 }`

Different types of fragments

There are two classes within the Fragment name:
1. android.app.Fragment: This is the version of fragment built into Android OS.
This has the framework version and the v4 support library version.
Both are legacy versions of Fragment class.
The framework implementation of fragments was built into devices running API level 11 or higher.
The fragment implementation was added to v4 support library to enable fragment support on older devices.
2. androidx.fragment.app.Fragment: This is the jetpack version of fragments.
But as of Android 9(API 28), the framework version of fragments is deprecated and earlier support library fragments have been moved to Jetpack libraries.

Implementing Fragment lifecycle functions
`class CrimeDetailFragment: Fragment() {    
    private lateinit var crime: Crime            
    override fun onCreate(savedInstanceState: Bundle?){   
    super.onCreate(savedInstanceState)                
    crime = Crime(           
            id = UUID.randomUUID(),            
            title = "",            
            date = Date(),            
            isSolved = false        
        )    
    }
}`

Fragments are also re-created on configuration changes by default.
** Fragment lifecycle functions must be public, because they will be called by whichever Activity is hosting the fragment.

** We do not inflate the fragment’s view in onCreate(Bundle?), only configure the instance.
We create the view in onCreateView(LayoutInflater, ViewGroup?, Bundle?), this is where we inflate and bind the layout for the fragment’s view and return the inflated View to the hosting Activity.

`override fun onCreateView(    
    inflater: LayoutInflater,    
    container: ViewGroup?,    
    savedInstanceState: Bundle?
): View? {    
    return ComposeView(requireContext()).apply {        
        setContent {                    
        }    
    }
}` 

Hosting a Fragment

** For compose only projects, we do not need Fragments.

To use a Fragment inside an Activity, the activity should be of type 
`AppCompatActivity` and it should have its own layout xml file.

FragmentContainerView

This is used in MainActivity xml layout file, to contain fragments.
Eg: activity_main.xml

`<?xml version="1.0" encoding="utf-8"?>
<androidx.fragment.app.FragmentContainerView    
    android:id="@+id/fragment_container"
    xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"    
    android:layout_height="match_parent"
    android:name="com.bignerdranch.criminalintent.CrimeDetailFragment"></androidx.fragment.app.FragmentContainerView>`

With the help of attribute name, FragmentContainerView will manage to create your desired Fragment and insert it in activity’s layout.

** If we are using AppCompatActivity, then we need to ensure the theme used is also Theme.AppCompat

** UI overlapping with notch:
1. Need to enable edge-to-edge in MainActivity by adding  enableEdgeToEdge() in onCreate().
2. Apply System bar padding in our Composable.
modifier = Modifier.windowInsetsPadding(WindowInsets.safeDrawing)

The Fragment Manager

It is responsible for adding the fragments views to the activity’s view hierarchy and driving the fragments lifecycles.
It handles 2 things:
1. a list of fragments
2. a back stack of fragment transaction
** FragmentContainerView uses FragmentManager to create and host the fragment you specified in the android:name XML attribute.

We can also attach fragments to activities using FragmentManager, also to remove, replace or alter navigation back stack.
Eg: onCreate method in MainActivity.kt

`if (savedInstanceState == null) {    
    supportFragmentManager        
        .beginTransaction()        
        .add(R.id.fragment_container, CrimeDetailFragment())        
        .commit()}`

Checking for savedInstanceState as null, prevents creating duplicate components when the screen rotates or system otherwise re-creates your Activity.

FragmentManager.beginTransaction() function creates and returns an instance of FragmentTransaction.
The FragmentTransaction class uses fluent interface - function that configure FragmentTransaction return FragmentTransaction instead of Unit, which allows us to chain them together.

A container view ID serves two purpose:
1. Tells the FragmentManager where in the activity’s view the fragment’s view should appear.
2. Used as unique identifier for a fragment in FragmentManager’s list.

The fragment lifecycle

It is similar to Activity lifecycle, it has Created, Started, and Resumed state.

![image.png](attachment:299afdf7-f437-47fe-924c-3e2c5650ee0a:image.png)

** Correspondance in lifecycle states
Because a Fragment works on behalf of an Activity, it state should reflect the activity’s state, hence needs corresponding lifecycle functions to handle activity’s work.

** Fragment lifecycle functions are called by the FragmentManger of the hosting activity, not the OS.

What happens if we add Fragment while Activity is in Resumed state?
In this case FragmentManager immediately walks the fragment through whatever steps are necessary to get it caught up to Activity’s state.

Fragments and memory management

Since Fragments can be swapped in and out as the user navigates your app, they are usually retained in memory, to keep it ready to use in-case user presses back button.

**But its view is not kept it in memory, since Fragment is not being displayed.
onDestroyView() and onCreateView() are used respectively to destroy and re-create view.

Since we hold reference to View in binding property in onCreateView(…), the view is not cleared from memory, this leads to wastage of resources. As we keep the view in Memory, even though it will be re-created again by calling onCreateView() or entire Fragment is destroyed.

Solution: Null out any references to view in onDestroyView() lifecycle callback.
This will help in performance boost by freeing up unused resources.

**In case of Compose, the system handles this for us, so no need to manually nullify compose reference.
[1.](http://1.no/) No binding Property: 
In your CrimeDetailFragment, you are creating the ComposeView as a local variable inside the onCreateView method and returning it directly. You are not holding it in a fragment-level property like you would with View Binding (private var binding: ResultProfileBinding? = null). Since there is no persistent reference held by the fragment instance itself, there's nothing for you to nullify.

2.Lifecycle Management: 
The ComposeView is a View just like any other Android View. The fragment's View lifecycle is responsible for managing it. When onDestroyView is called, the fragment's entire view hierarchy, including the ComposeView you returned, is detached from the window and becomes eligible for garbage collection. The system handles this for you.

3.The Role of setContent: 
The setContent block is where the magic happens. It links your Composable functions to the ComposeView and, more importantly, to the lifecycle of the host. The ComposeView automatically disposes of its composition when it's detached from the window, which happens during the fragment's onDestroyView phase. This ensures that any state (remember, mutableStateOf, etc.) and resources held by your composables are properly released.

Eg: CrimeDetailFragment.kt
private val *binding: FragmentCrimeDetailBinding? = null
private val binding
    get() = checkNotNull(_binding) { 
        “Cannot access binding as its null”
    }
override onCreateView(…): View{
    _binding = FragmentCrimeDetailBinding(layoutInflater, container, false)
   return binding.root
}
override onDestroyView(){
    super.onDestroyView()
    _binding = null
}*

Testing
Fragments have FragmentScenario to test them in isolation, for UI tests.
debugImplementation “androidx.fragment:fragment-testing:1.4.1”
** FragmentScenario library inserts an Activity into our app and uses it to host our Fragment in a container it can control for testing it.
